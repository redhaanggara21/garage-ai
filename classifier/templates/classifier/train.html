<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>CNN + XGBoost Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Chart.js Matrix Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@1.0.0/dist/chartjs-chart-matrix.min.js"></script>
    <!-- Plotly -->
    <script src="https://cdn.plot.ly/plotly-2.34.0.min.js"></script>
</head>

<body class="p-4">
    <div class="container">
        <h2>CNN + XGBoost Training Dashboard</h2>

        <!-- Start/Stop Training -->
        <button id="start-stop-btn" class="btn btn-primary mt-3">Start Training</button>

        <!-- Progress Bar -->
        <div class="progress mt-3" style="height:30px;">
            <div id="progress-bar" class="progress-bar" role="progressbar" style="width:0%">0%</div>
        </div>
        <div id="progress-info" class="mt-1">Epoch: 0 / 0 | Loss: 0.0 | Accuracy: 0.0</div>

        <!-- Metrics Chart -->
        <h4 class="mt-4">Training Metrics</h4>
        <canvas id="metrics-chart" height="150"></canvas>

        <!-- Confusion Matrix -->
        <h4 class="mt-4">Confusion Matrix (Interactive Heatmap)</h4>
        <canvas id="confusion-chart" height="200"></canvas>

        <!-- 3D Scatter Plot -->
        <h4 class="mt-4">3D Class Distribution</h4>
        <div id="scatter-3d" style="width:100%;height:400px;"></div>

        <!-- Metrics Text -->
        <div class="mt-2">
            <span id="metric-precision">Precision: 0.0</span> |
            <span id="metric-recall">Recall: 0.0</span> |
            <span id="metric-f1">F1: 0.0</span>
        </div>

        <!-- Download Models -->
        <div id="download-section" style="display:none; margin-top:20px;">
            <h4>Download Models</h4>
            <a href="/classifier/models/cnn_model.h5" download class="btn btn-success">CNN (.h5)</a>
            <a href="/classifier/models/xgb_model.pkl" download class="btn btn-success">XGBoost (.pkl)</a>
        </div>
    </div>

    <script>
        let training = false;
        const startStopBtn = document.getElementById("start-stop-btn");
        const progressBar = document.getElementById("progress-bar");
        const progressInfo = document.getElementById("progress-info");
        const downloadSection = document.getElementById("download-section");
        let scatterPlot = null;

        // Metrics Chart
        let metricsChart = new Chart(document.getElementById('metrics-chart').getContext('2d'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Loss', data: [], borderColor: 'red', fill: false },
                    { label: 'Accuracy', data: [], borderColor: 'green', fill: false }
                ]
            },
            options: { responsive: true, animation: false }
        });

        // ===============================
        // Confusion Matrix â€“ Dynamic Grid
        // ===============================
        function getClassCount(cm) {
            if (!cm || !cm.length) return 0;
            return cm.length;
        }

        function updateConfusionMatrix(cm, classLabels = null) {
            if (!cm) return;

            const nClasses = getClassCount(cm);
            const labels = classLabels || Array.from({ length: nClasses }, (_, i) => `Class ${i}`);

            const matrixData = [];
            for (let i = 0; i < nClasses; i++) {
                for (let j = 0; j < nClasses; j++) {
                    matrixData.push({ x: j, y: i, v: cm[i][j] });
                }
            }

            confusionChart.data.datasets[0].data = matrixData;
            confusionChart.options.scales.x.labels = labels;
            confusionChart.options.scales.y.labels = labels;
            confusionChart.update();
        }

        const confusionChart = new Chart(document.getElementById('confusion-chart').getContext('2d'), {
            type: 'matrix',
            data: {
                datasets: [{
                    label: 'Confusion Matrix', data: [], backgroundColor: function (ctx) {
                        const item = ctx.dataset.data[ctx.dataIndex];
                        if (!item) return 'rgba(0,0,0,0)';
                        const alpha = Math.min(item.v / 10, 1);
                        return `rgba(255,0,0,${alpha})`;
                    }, width: function (ctx) {
                        const a = ctx.chart.chartArea;
                        const n = ctx.chart.data.datasets[0].data ? Math.sqrt(ctx.chart.data.datasets[0].data.length) : 1;
                        return a ? (a.right - a.left) / n - 1 : 0;
                    }, height: function (ctx) {
                        const a = ctx.chart.chartArea;
                        const n = ctx.chart.data.datasets[0].data ? Math.sqrt(ctx.chart.data.datasets[0].data.length) : 1;
                        return a ? (a.bottom - a.top) / n - 1 : 0;
                    }
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            title: () => "",
                            label: function (context) {
                                const item = context.raw;
                                if (!item) return '';
                                const labels = context.chart.options.scales.x.labels || [];
                                return `Pred: ${labels[item.x]}, True: ${labels[item.y]}, Count: ${item.v}`;
                            }
                        }
                    }
                },
                scales: {
                    x: { type: 'category', labels: [], offset: true },
                    y: { type: 'category', labels: [], offset: true, reverse: true }
                }
            }
        });

        // 3D Scatter Plot
        function updateScatter3D(scatterFeatures) {
            if (!scatterFeatures || scatterFeatures.length === 0) return;
            const x = scatterFeatures.map(pt => pt.x);
            const y = scatterFeatures.map(pt => pt.y);
            const z = scatterFeatures.map(pt => pt.z || 0);
            const colors = scatterFeatures.map(pt => pt.label === 'minor' ? 'blue' : pt.label === 'moderate' ? 'orange' : 'red');
            const trace = { x, y, z, mode: 'markers', type: 'scatter3d', marker: { size: 4, color: colors } };
            const layout = { margin: { l: 0, r: 0, b: 0, t: 0 } };
            if (!scatterPlot) scatterPlot = Plotly.newPlot('scatter-3d', [trace], layout);
            else Plotly.react('scatter-3d', [trace], layout);
        }

        // Start/Stop Training
        startStopBtn.addEventListener('click', () => {
            if (!training) {
                fetch('/start-training/', { method: 'POST' });
                training = true;
                startStopBtn.innerText = "Stop Training";
            } else {
                fetch('/stop-training/', { method: 'POST' })
                    .then(res => res.json())
                    .then(d => alert(d.message));
            }
        });

        // Live Progress
        async function liveProgress() {
            try {
                const res = await fetch('/get-progress-training/');
                const data = await res.json();

                const percent = data.total_epochs > 0 ? (data.epoch / data.total_epochs * 100) : 0;
                progressBar.style.width = percent + "%";
                progressBar.innerText = Math.round(percent) + "%";
                progressInfo.innerText = `Epoch: ${data.epoch} / ${data.total_epochs} | Loss: ${data.loss} | Accuracy: ${data.accuracy}`;

                if (!metricsChart.data.labels.includes(data.epoch)) {
                    metricsChart.data.labels.push(data.epoch);
                    metricsChart.data.datasets[0].data.push(data.loss);
                    metricsChart.data.datasets[1].data.push(data.accuracy);
                    metricsChart.update();
                }

                if (data.metrics?.confusion_matrix) updateConfusionMatrix(data.metrics.confusion_matrix, data.metrics?.class_labels);

                document.getElementById('metric-precision').innerText = "Precision: " + (data.metrics?.precision || 0);
                document.getElementById('metric-recall').innerText = "Recall: " + (data.metrics?.recall || 0);
                document.getElementById('metric-f1').innerText = "F1: " + (data.metrics?.f1 || 0);

                if (data.scatter_features) updateScatter3D(data.scatter_features);

                downloadSection.style.display = data.status === "done" ? "block" : "none";

                if (data.status === "done" || data.status === "stopped") {
                    training = false;
                    startStopBtn.innerText = "Start Training";
                } else setTimeout(liveProgress, 1000);

            } catch (e) {
                setTimeout(liveProgress, 2000);
            }
        }

        document.addEventListener("DOMContentLoaded", liveProgress);
    </script>
</body>

</html>